const JSZip = require('jszip');
const util = require('./utils');
var MidiWriter = require('midi-writer-js');

//歌谱和midi
class CCMZ {
  ver;
  score;
  midi;
}

const libCCMZ = {
  //下载CCMZ
  downloadCCMZ(url) {
    return util.httpget(url, '', true, '琴谱文件', false);
  },

  //解析CCMZ文件，来自Controller.js
  readCCMZ(buffer, callback) {
    let info = new CCMZ();
    let version = (new Uint8Array(buffer.slice(0, 1)))[0];
    console.log("CCMZ版本:", version);
    info.ver = version;
    let data = new Uint8Array(buffer.slice(1));
    if (version == 1) {
      JSZip.loadAsync(data).then((zip) => {
        zip.file("data.xml").async("string").then((json) => {
          info.score = json;
          zip.file("data.mid").async("string").then((json) => {
            info.midi = json;
            callback(info);
          });
        });
      });
    } else if (version == 2) {
      data = data.map((value) => value % 2 == 0 ? value + 1 : value - 1);
      JSZip.loadAsync(data).then((zip) => {
        zip.file("score.json").async("string").then((json) => {
          info.score = json;
          zip.file("midi.json").async("string").then((json) => {
            info.midi = json;
            callback(info);
          });
        });
      });
    }
  },

  //转换为MID文件
  writeMIDI(input, outputFile) {
    const baseMultiplier = 0.25;
    if (!input['tempos'] || !input['tempos'][0] || isNaN(input['tempos'][0]['tempo'])) {
      throw new Error('Invalid tempo data'); //遇事不决直接报错
    }
    const initialTempo = input['tempos'][0]['tempo'];

    let tracks = []; //喜欢这样写:)
    for (let t in input['tracks']) {
      let trackOrig = input['tracks'][parseInt(t)];
      let currTrack = new MidiWriter.Track();
      currTrack.addText('Generated by chongchong-free'); //水印，可以不加
      currTrack.addEvent(new MidiWriter.ProgramChangeEvent({
        instrument: 1
      })); //乐器是钢琴
      let name = trackOrig['name'] !== '' ? trackOrig['name'] : 'unnamed'; //音轨名称
      currTrack.addTrackName(name);
      currTrack.setTempo(Math.round(60000000 / initialTempo), 0); //初始速度

      let globalOffset = 0; //全局偏移量
      for (let ev in input['events']) {
        let event = input['events'][parseInt(ev)];
        if (event['duration'] == 0 || !event['staff']) { //跳过无效事件
          event['validEvent'] = false;
          continue;
        } else {
          event['validEvent'] = true;
        }
        if (event['tick'] == 0) event['tick'] = 1; //修复 tick 为 0 的问题

        let lastValidEvent = event;
        for (let _ev = parseInt(ev); _ev > 0; _ev--) {
          if (input['events'][_ev - 1]['validEvent'] == true) {
            lastValidEvent = input['events'][_ev - 1];
            break;
          }
        }

        let currTempo = initialTempo; //当前速度
        let lastTempo = initialTempo; //上一个的速度
        for (let tpo of input['tempos']) {
          if (tpo['tick'] <= event['tick']) {
            lastTempo = currTempo;
            currTempo = tpo['tempo'];
          } else {
            break;
          }
        }
        if (isNaN(currTempo) || currTempo === 0) throw new Error('Invalid currTempo'); //遇事不决直接炸
        if (isNaN(lastTempo)) throw new Error('Invalid lastTempo'); //遇事不决直接炸

        let mDuration = baseMultiplier * lastTempo / currTempo;
        let mTick = baseMultiplier * lastTempo / currTempo;
        let tickDelta = event['tick'] - lastValidEvent['tick'];
        globalOffset += tickDelta * mTick;
        if (event['tick'] + globalOffset < 0) globalOffset = 0;

        if (isNaN(event['duration']) || event['duration'] <= 0) {
          throw new Error(`Invalid event duration: ${event['duration']}`); //这个应该永远不会触发(
        }

        let note = new MidiWriter.NoteEvent({
          velocity: 80,
          pitch: [event['event'][1]],
          duration: "T" + event['duration'] * mDuration,
          startTick: globalOffset,
        });

        let trackID = event['staff'] - 1;
        if (parseInt(t) == trackID) currTrack.addEvent(note);
      }
      tracks.push(currTrack);
    }
    //写出
    if (util.isDetailedOutput()) console.log('开始写出MIDI文件');
    let writer = new MidiWriter.Writer(tracks);
    require('fs').writeFileSync(outputFile, writer.buildFile());
  }
};

module.exports = libCCMZ;

//MIDI类

class MeasureInfo {
  beats; //拍子
  number; //序号
  fifths; //升降调
  beatUnit; //拍子
}

class Event {
  tick; //时间
  duration; //持续时长
  track; //音轨序号
  event; //按键
  finger; //手指
  note; //未知
  part; //未知
  repeatIndex; //重复次数
  staff; //未知
  measure; //所在小节号
  elem_ids; //未知
  meas_start_tick; //小节开始时间
  id; //未知
}

class Measure {
  duration; //小节时长
  note_ticks; //每个音符出现时间
  measure; //小节号
}

class TempoChange {
  tempo; //速度
  tick; //时间
}

class Track {
  channel; //未知
  name; //名称
  program; //未知
}

class BeatChange {
  beats; //拍子
  beatsUnit; //拍子
  tick; //时间
}

class MIDI {
  ver; //版本号
  leftHandTrack; //低音音轨
  rightHandTrack; //高音音轨
  roughProgress; //未知
  beats; //拍号
  beatsUnit; //拍号
  beatInfos; //变拍子
  tempos; //变速
  tracks; //音轨
  measures; //小节
  measureInfos; //小节信息
  lyrics; //歌词
  events; //midi的event
}